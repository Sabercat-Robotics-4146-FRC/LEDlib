/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package LEDlib;

public class LEDPerimeter {
    static double frameWidth;
    static double frameLength;
    static double frameAngle = Math.atan2(frameWidth, frameLength);
    static double distanceTraveled;


    static int region;

    public static class edgePoint {
        static double x = 0;
        static double y = 0;
    }

    public static class nearestCorner {
        static double x;
        static double y;
    }

    static double yFactor = 1;
    static double xFactor = 1;

    public LEDPerimeter(double FrameWidth, double FrameLength) {
        frameWidth = FrameWidth;
        frameLength = FrameLength;
    }

    public void getregion(double angle) {
          if ((angle > -frameAngle) && (angle <= frameAngle)) {
      region = 1;
        } else if ((angle > frameAngle) && (angle <= (Math.PI - frameAngle))) {
      region = 2;
        } else if ((angle > (Math.PI - frameAngle)) || (angle <= -(Math.PI - frameAngle))) {
      region = 3;
        } else {
      region = 4;
        }
    }
    
    public void setEdgePoint(double headingAngle) {
        double tanTheta = Math.tan(headingAngle);
        getregion(headingAngle);

        switch (region) {
            case 1: yFactor = -1; break;
            case 2: yFactor = -1; break;
            case 3: xFactor = -1; break;
            case 4: xFactor = -1; break;
        }
  

        if ((region == 1) || (region == 3)) {
            edgePoint.x += xFactor * (frameLength / 2.);                                     // "Z0"
            edgePoint.y += yFactor * (frameLength / 2.) * tanTheta;
        } else {
            edgePoint.x += xFactor * (frameWidth / (2. * tanTheta));                        // "Z1"
            edgePoint.y += yFactor * (frameWidth /  2.);
        }
    }

    public double getLEDNum(double headingAngle) {
        setEdgePoint(headingAngle);
        getregion(headingAngle);
        switch (region) {
            case 1: distanceTraveled = 0;
                    nearestCorner.x = frameLength/2;
                    if (headingAngle > (7*Math.PI)/4) {
                        nearestCorner.y = -frameWidth/2;
                    } else {
                        nearestCorner.y = frameWidth/2;
                    }
            case 2: distanceTraveled = frameWidth/2;
                    nearestCorner.x = frameLength/2;
                    nearestCorner.y = frameWidth/2;
            case 3: distanceTraveled = frameLength + frameWidth/2;
                    nearestCorner.x = -frameLength/2;
                    nearestCorner.y = frameWidth/2;
            case 4: distanceTraveled = frameLength + (3* frameWidth)/2;
                    nearestCorner.x = -frameLength/2;
                    nearestCorner.y = -frameWidth/2;
        }
            distanceTraveled = distanceTraveled + Math.sqrt(Math.pow(nearestCorner.x -edgePoint.x, 2) + Math.pow(nearestCorner.y -edgePoint.y, 2));

            return ((double)(150)/112) * distanceTraveled;


    }


}
